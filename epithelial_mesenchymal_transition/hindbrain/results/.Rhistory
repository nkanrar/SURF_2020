x <- c(1,2,3); x
myMA <- matrix(1:30, 3, 10, byrow = TRUE)
class(myMA) [1]
myMA[1:2,]
myDF <- data.frame(Col1=1:10, Col2=10:1)
myDF[1:2,]
dim(myDF)
myL <- list(name="Fred", wife="Mary", no.children=3, child.ages=c(4,7,9))
myL
myL$name
myL[[4]][1:2]
myVec <- 1:26; names(myVec) <- LETTERS
myVec[1:4]
myLog <- myVec > 10
myVec[myLog]
myVec[c("B", "K", "M")]
iris$Species[1:8]
1==1
x <- 1:5; y <- 5:1
x>y&x>3
x+y
sum(x)
mean(x)
c(1,2,3)
x<-1:3;y<-51:53
c(x,y)
ma <- cbind(x,y)
ma
dim(ma)
class(ma)
rbind(ma,ma)
history() # display last 25 commands
history(max.show=Inf) # display all previous commands
savehistory(file="myfile") # default is ".Rhistory"
getwd()
dir()
install.packages("ggplot2")
ls(pos = "package:ggplot2")
library(ggplot2)
ls(pos = "package:ggplot2")
source("https://bioconductor.org/biocLite.R")
biocLite("DESeq2")
browseVignettes("DESeq2")
dim(iris)
iris[1,]
iris[1:5,]
class(iris)
names(iris)
length(iris$Sepal.Length)
levels(iris$Species)
iris$Species[1:8]
length(unique(iris$Sepal.Length))
names(iris) %in% c("Species","Petal.Width")
names(iris)
which(names(iris)) %in% c("Species", "Petal.Width")
which(names(iris) %in% c("Species", "Petal.Width"))
iris[which(names(iris) %in% c("Species", "Petal.Width"))]
month.name %in% c("May", "July")
table(iris$Species)
frame1 <- iris[sample(1:length(iris[,1]), 30), ]
frame1[1:2,]
dim(frame1) [1]
write.table(iris, file="myData.xls",sep="\t", quote=FALSE, col.names=NA)
myDF <- read.delim("myData.xls", sep="\t")
for(year in 2010:2015{
print(paste("The year is",year))
})
for(year in 2010:2015){
print(paste("The year is",year))
}
words.names = function(x) {
for(name in x){
print(name)
}
}
words = c("R", "datascience", "machinelearning","algorithms","AI")
words.names(words)
bar <- barplot(m <- rowMeans(y) * 10, ylim=c(0, 10))
set.seed(1410)
y <- matrix(runif(30), ncol=3, dimnames=list(letters[1:10], LETTERS[1:3]))
plot(y[,1], y[,2])
bar <- barplot(m <- rowMeans(y) * 10, ylim=c(0, 10))
stdev <- sd(t(y))
arrows(bar, m, bar, m + stdev, length=0.15, angle = 90)
hist(y, freq=TRUE, breaks=10)
bar <- barplot(m <- rowMeans(y) * 10, ylim=c(0, 10))
stdev <- sd(t(y))
arrows(bar, m, bar, m + stdev, length=0.15, angle = 90)
hist(y, freq=TRUE, breaks=10)
install.packages("ggplot2")
jpeg('rplot.jpg')
plot(x,y)
dev.off()
pdf("save_plot.pdf")
hist(y, freq=TRUE, breaks=10)
dev.off()
source("https://bioconductor.org/biocLite.R")
biocLite("GenomicRanges")
biocLite("rtracklayer")
library(GenomicRanges)
library(rtracklayer)
library(GenomicRanges); library(rtracklayer)
gr <- GRanges(seqnames = Rle(c("chr1", "chr2", "chr1", "chr3"), c(1, 3, 2, 4)), ranges = IRanges(1:10, end = 7:16, names = head(letters, 10)), strand = Rle(strand(c("-", "+", "*", "+", "-")), c(1, 2, 2, 3, 2)), score = 1:10, GC = seq(1, 0, length = 10)) # Example of creating a GRanges object with its constructor function.
gff <- import.gff("http://faculty.ucr.edu/~tgirke/Documents/R_BioCond/Samples/gff3.gff") # Imports a simplified GFF3 genome annotation file.
seqlengths(gff) <- end(ranges(gff[which(values(gff)[,"type"]=="chromosome"),])); names(gff) <- 1:length(gff) # Assigns names to corresponding slot gff[1:4,]
x <- c(1,2,3); x
x <- c(1,2,3); x
x <- 1:6 < 5
which(x)
myVec <- 1:10; names(myVec) <- letters[1:10]
myVec[1:5]
myMA <- matrix(1:30, 3, 10, byrow = TRUE)
class(myMA) [1]
myMA[1:2,]
myDF <- data.frame(Col1=1:10, Col2=10:1)
myDF[1:2,]
dim(myDF)
myL <- list(name="Fred", wife="Mary", no.children=3, child.ages=c(4,7,9))
myL
myL$name
myL[[4]][1:2]
myVec <- 1:26; names(myVec) <- LETTERS
myVec[1:4]
myLog <- myVec > 10
myVec[myLog]
myVec[c("B", "K", "M")]
1==1
x <- 1:5; y <- 5:1
x>y&x>3
x+y
sum(x)
mean(x)
c(1,2,3)
x<-1:3;y<-51:53
c(x,y)
ma <- cbind(x,y)
ma
rbind(ma,ma)
?function_name
function_name
?plot
plot
vignette("my_library")
history() # display last 25 commands
history(max.show=Inf) # display all previous commands
getwd()
dir()
install.packages("ggplot2")
library(ggplot2)
install.packages("ggplot2")
install.packages("ggplot2")
library(ggplot2)
ls("package:ggplot2")
source("https://bioconductor.org/biocLite.R")
biocLite("DESeq2")
browseVignettes("DESeq2")
class(iris)
dim(iris)
names(iris)
iris[1,]
levels(iris$Species)
length(unique(iris$Sepal.Length))
names(iris) %in% c("Species","Petal.Width")
month.name %in% c("May", "July")
table(iris$Species)
write.table(iris, file="myData.xls",sep="\t", quote=FALSE, col.names=NA)
myDF <- read.delim("myData.xls", sep="\t")
my.DF[1,]
myDF[1,]
for(year in 2010:2015){
print(paste("The year is",year))
}
words.names = function(x) {
for(name in x){
print(name)
}
}
words = c("R", "datascience", "machinelearning","algorithms","AI")
words.names(words)
1:5
x <- "R Tutorial"
gsub("ut","ot",x)
str = 'Now is the time '
sub(' +$', '', str) ## spaces only
set.seed(1410)
y <- matrix(runif(30), ncol=3, dimnames=list(letters[1:10], LETTERS[1:3]))
plot(y[,1], y[,2])
counts <- table(mtcars$vs, mtcars$gear)
barplot(counts, main="Car Distribution by Gears and VS", xlab="Number of Gears", col=c("darkblue","red"),legend = rownames(counts))
bar <- barplot(m <- rowMeans(y) * 10, ylim=c(0, 10))
stdev <- sd(t(y))
arrows(bar, m, bar, m + stdev, length=0.15, angle = 90)
hist(y, freq=TRUE, breaks=10)
install.packages("ggplot2")
install.packages("ggplot2")
library(ggplot2)
df.team_data <- expand.grid(teams = c("Team A", "Team B", "Team C", "Team D")
,metrics = c("Metric 1", "Metric 2", "Metric 3", "Metric 4", "Metric 5")
)
set.seed(41)
df.team_data$performance <- rnorm(nrow(df.team_data))
head(df.team_data)
ggplot(data = df.team_data, aes(x = metrics, y = teams)) +
geom_tile(aes(fill = performance))
jpeg('rplot.jpg')
plot(x,y)
dev.off()
pdf("save_plot.pdf")
hist(y, freq=TRUE, breaks=10)
dev.off()
sessionInfo()
biocLite("BiocStyle")
source("https://bioconductor.org/biocLite.R")
biocLite("BiocStyle")
library(rmarkdown)
library(knitr)
biocLite("GenomicRanges")
biocLite("rtracklayer")
library(GenomicRanges)
library(rtracklayer)
library(GenomicRanges); library(rtracklayer)
gr <- GRanges(seqnames = Rle(c("chr1", "chr2", "chr1", "chr3"), c(1, 3, 2, 4)), ranges = IRanges(1:10, end = 7:16, names = head(letters, 10)), strand = Rle(strand(c("-", "+", "*", "+", "-")), c(1, 2, 2, 3, 2)), score = 1:10, GC = seq(1, 0, length = 10)) # Example of creating a GRanges object with its constructor function.
gff <- import.gff("http://faculty.ucr.edu/~tgirke/Documents/R_BioCond/Samples/gff3.gff") # Imports a simplified GFF3 genome annotation file.
seqlengths(gff) <- end(ranges(gff[which(values(gff)[,"type"]=="chromosome"),])); names(gff) <- 1:length(gff) # Assigns names to corresponding slot gff[1:4,]
as.data.frame(gff)[1:4, 1:7]
gff_rd <- as(gff, "RangedData")
gff_gr <- as(gff_rd, "GRanges")
gff[1:4]
gff[1:4, c("type", "ID")]
strand(gff)
seqlengths(gff)
start(gff[1:4])
end(gff[1:4])
width(gff[1:4])
seqnames(gff)
ranges(gff)
values(gff)
q()
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
library(BiocManager)
BiocManager::install("slingshot")
browseVignettes("slingshot")
library(slingshot)
?slingshot
?slingshot
?slingshot
setwd("~/Documents/SURF 2020/RNA_seq_files/epithelial_mesenchymal_transition/hindbrain/results")
setwd("~/Documents/SURF 2020/RNA_seq_files/epithelial_mesenchymal_transition/hindbrain/results")
setwd("~/Documents/SURF 2020/SURF_2020/SURF_2020/epithelial_mesenchymal_transition/hindbrain/results")
library(slingshot)
library(scales)
library(viridis)
df <- read.csv("forebrain_slingshot_data.csv", header=TRUE, row.names="X")
df <- read.csv("hindbrain_slingshot_data.csv", header=TRUE, row.names="X")
head(df)
UMAPs <- c("X_fa_1", "X_fa_1")
UMAP_coords <- df[UMAPs]
head(UMAP_coords)
UMAPs <- c("X_fa_1", "X_fa_2")
UMAP_coords <- df[UMAPs]
head(UMAP_coords)
cluster_labels = df$leiden
cluster_labels
sling_output<-slingshot(UMAP_coords,
clusterLabels = cluster_labels,
start.clus = 5,
end.clus = c(4,6),
approx_points = 200)
sling_output
cell_pal <- function(cell_vars, pal_fun,...) {
if (is.numeric(cell_vars)) {
pal <- pal_fun(100, ...)
return(pal[cut(cell_vars, breaks = 100)])
} else {
categories <- sort(unique(cell_vars))
pal <- setNames(pal_fun(length(categories), ...), categories)
return(pal[cell_vars])
}
}
cell_colors_clust <- cell_pal(cluster_labels, hue_pal())
plot(reducedDim(sling_output),
col = cell_colors_clust, # A color array: one color for each cell (color corresponds to cluster)
pch = 16, # graphical parameters for scatterplot: type of dot
cex = 0.5, # size of dots
cex.lab = 1.5, # label font size
cex.axis = 1) # axis font size
lines(sling_output, lwd = 2, col = 'black')
sling_output<-slingshot(UMAP_coords,
clusterLabels = cluster_labels,
start.clus = 5,
approx_points = 200)
sling_output
cell_pal <- function(cell_vars, pal_fun,...) {
if (is.numeric(cell_vars)) {
pal <- pal_fun(100, ...)
return(pal[cut(cell_vars, breaks = 100)])
} else {
categories <- sort(unique(cell_vars))
pal <- setNames(pal_fun(length(categories), ...), categories)
return(pal[cell_vars])
}
}
cell_colors_clust <- cell_pal(cluster_labels, hue_pal())
plot(reducedDim(sling_output),
col = cell_colors_clust, # A color array: one color for each cell (color corresponds to cluster)
pch = 16, # graphical parameters for scatterplot: type of dot
cex = 0.5, # size of dots
cex.lab = 1.5, # label font size
cex.axis = 1) # axis font size
lines(sling_output, lwd = 2, col = 'black')
sling_output<-slingshot(UMAP_coords,
clusterLabels = cluster_labels,
start.clus = 5,
end.clus = c(4,6),
approx_points = 200)
sling_output
cell_pal <- function(cell_vars, pal_fun,...) {
if (is.numeric(cell_vars)) {
pal <- pal_fun(100, ...)
return(pal[cut(cell_vars, breaks = 100)])
} else {
categories <- sort(unique(cell_vars))
pal <- setNames(pal_fun(length(categories), ...), categories)
return(pal[cell_vars])
}
}
cell_colors_clust <- cell_pal(cluster_labels, hue_pal())
plot(reducedDim(sling_output),
col = cell_colors_clust, # A color array: one color for each cell (color corresponds to cluster)
pch = 16, # graphical parameters for scatterplot: type of dot
cex = 0.5, # size of dots
cex.lab = 1.5, # label font size
cex.axis = 1) # axis font size
lines(sling_output, lwd = 2, col = 'black')
UMAPs <- c("X_pca_1 ", "X_pca_2", "X_pca_3", "X_pca_4", "X_pca_5")
UMAP_coords <- df[UMAPs]
UMAP_coords <- df[UMAPs]
UMAPs <- c("X_pca_1", "X_pca_2", "X_pca_3", "X_pca_4", "X_pca_5")
UMAP_coords <- df[UMAPs]
head(UMAP_coords)
cluster_labels = df$leiden
cluster_labels
sling_output<-slingshot(UMAP_coords,
clusterLabels = cluster_labels,
start.clus = 5,
end.clus = c(4,6),
approx_points = 200)
sling_output
cell_pal <- function(cell_vars, pal_fun,...) {
if (is.numeric(cell_vars)) {
pal <- pal_fun(100, ...)
return(pal[cut(cell_vars, breaks = 100)])
} else {
categories <- sort(unique(cell_vars))
pal <- setNames(pal_fun(length(categories), ...), categories)
return(pal[cell_vars])
}
}
cell_colors_clust <- cell_pal(cluster_labels, hue_pal())
plot(reducedDim(sling_output),
col = cell_colors_clust, # A color array: one color for each cell (color corresponds to cluster)
pch = 16, # graphical parameters for scatterplot: type of dot
cex = 0.5, # size of dots
cex.lab = 1.5, # label font size
cex.axis = 1) # axis font size
lines(sling_output, lwd = 2, col = 'black')
pt <- slingPseudotime(sling_output)
nms <- colnames(pt)
df <- read.csv("hindbrain_slingshot_data.csv", header=TRUE, row.names="X")
head(df)
UMAPs <- c("X_umap_1", "X_umap_2")
UMAP_coords <- df[UMAPs]
head(UMAP_coords)
cluster_labels = df$leiden
cluster_labels
sling_output<-slingshot(UMAP_coords,
clusterLabels = cluster_labels,
start.clus = 2,
end.clus = c(3,6),
approx_points = 200)
sling_output
cell_pal <- function(cell_vars, pal_fun,...) {
if (is.numeric(cell_vars)) {
pal <- pal_fun(100, ...)
return(pal[cut(cell_vars, breaks = 100)])
} else {
categories <- sort(unique(cell_vars))
pal <- setNames(pal_fun(length(categories), ...), categories)
return(pal[cell_vars])
}
}
cell_colors_clust <- cell_pal(cluster_labels, hue_pal())
plot(reducedDim(sling_output),
col = cell_colors_clust, # A color array: one color for each cell (color corresponds to cluster)
pch = 16, # graphical parameters for scatterplot: type of dot
cex = 0.5, # size of dots
cex.lab = 1.5, # label font size
cex.axis = 1) # axis font size
lines(sling_output, lwd = 2, col = 'black')
UMAPs <- c("X_fa_1", "X_fa_2")
UMAP_coords <- df[UMAPs]
head(UMAP_coords)
cluster_labels = df$leiden
cluster_labels
sling_output<-slingshot(UMAP_coords,
clusterLabels = cluster_labels,
start.clus = 2,
end.clus = c(3,6),
approx_points = 200)
sling_output
cell_pal <- function(cell_vars, pal_fun,...) {
if (is.numeric(cell_vars)) {
pal <- pal_fun(100, ...)
return(pal[cut(cell_vars, breaks = 100)])
} else {
categories <- sort(unique(cell_vars))
pal <- setNames(pal_fun(length(categories), ...), categories)
return(pal[cell_vars])
}
}
cell_colors_clust <- cell_pal(cluster_labels, hue_pal())
plot(reducedDim(sling_output),
col = cell_colors_clust, # A color array: one color for each cell (color corresponds to cluster)
pch = 16, # graphical parameters for scatterplot: type of dot
cex = 0.5, # size of dots
cex.lab = 1.5, # label font size
cex.axis = 1) # axis font size
lines(sling_output, lwd = 2, col = 'black')
pt <- slingPseudotime(sling_output)
nms <- colnames(pt)
pal <- viridis(100, end = 0.95)
par(mfrow = c(5, 6))
for (i in nms) {
# This command subsets the trajectory i
# And bins the numeric values using 100 breaks
# Using our palette array pal, each bin gets a color that represents their progression in pseudotime
colors <- pal[cut(pt[,i], breaks = 100)]
# Cells that were not mapped to the current trajectory i
# will have NA values, which the colors array will keep as NA
# and the plotting function ignores by default. So we can do:
plot(UMAP_coords, col = colors, pch = 16, cex = 0.5, main = i)
# This plots the min spanning tree (analogous to PAGA in scanpy)
#lines(sling_output, lwd = 1, col = 'black', type = 'lineages')
}
write.table(pt,
file = './pseudotime_trajectories_slingshot.csv',
quote = F, #removes annoying quotes when writing to file,
sep=","
)
for (i in nms) {
# This command subsets the trajectory i
# And bins the numeric values using 100 breaks
# Using our palette array pal, each bin gets a color that represents their progression in pseudotime
colors <- pal[cut(pt[,i], breaks = 100)]
# Cells that were not mapped to the current trajectory i
# will have NA values, which the colors array will keep as NA
# and the plotting function ignores by default. So we can do:
plot(UMAP_coords, col = colors, pch = 16, cex = 0.5, main = i)
# This plots the min spanning tree (analogous to PAGA in scanpy)
#lines(sling_output, lwd = 1, col = 'black', type = 'lineages')
}
write.table(pt,
file = './pseudotime_trajectories_slingshot.csv',
quote = F, #removes annoying quotes when writing to file,
sep=","
)
